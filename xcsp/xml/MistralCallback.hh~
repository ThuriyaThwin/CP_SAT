#ifndef _MistralCallback_h_
#define _MistralCallback_h_

#include "CSPParserCallback.hh"
#include <mistral_sol.h>
#include <mistral_sat.h>

#define ShowNumericalIDS


using namespace Mistral;
using namespace std;

namespace CSPXMLParser {

  /**********************************************
   * Intentional Constraint
   **********************************************/ 

  

  // definition of the functions which are called by the parser when it
  // reads new information in the file. These functions are in charge of
  // creating the data structure that the solver needs to do his job
  class MistralCallback : public CSPParserCallback
  {
  public:
    
    // parser parameters
    int verbose;
    
    // timing
    double time_start;
    double time_now;
    double time_last;
    double time_solving;

    // solver
    Solver solver;
    // variables, as stated in the xml file
    VarArray X;

    // constraints

    // network params
    int numVariables;
    int numExtraVars;
    int numDomains;
    int numRelations;
    int numConstraints;
    int numPredicates;
    int numGlobal;
    int numWeightedSum;
    int numAllDiff;
    int numElement;
    int numCumulative;
    int numGlobalCardinality;

    int numBinExt;
    int numNaryExt;
    int numLargeExt;

    // domains
    int **domains;
    int *domainSize;
    int *domainMax;
    int *domainMin;
    int *D;    

    // constraints
    string constraintReference;
    VarArray constraintScope;
    VarArray predicateScope;
    //int *params;
    AST** predicates;
    int consArity;
    //int *predicateCount;
    //int *predicateScore;

    // utilities
    int countI, countJ, countK, maxCount, curCount, idcur;
    CSPDefinitionType curtype;

  public: 

    MistralCallback() {
      numExtraVars = numVariables = numDomains = numGlobal
	= numRelations = numConstraints = numPredicates 
	= numWeightedSum = numAllDiff = numElement 
	= numCumulative = numGlobalCardinality
	= numBinExt = numNaryExt = numLargeExt = 0;
    }

    virtual ~MistralCallback() 
      {
	cleanup();
      }

    virtual void beginInstance(const string & name)
    {
      if( verbose )
	cout << "c \nc start parsing xml file (" << name << ")" << endl;
      time_start = getRunTime();
    }

    virtual void beginDomainsSection(int nbDomains)
    {
      if( verbose ) {
	time_last = getRunTime();
	cout << "c" << setw(10) << " " << "domains....." ;
	cout.flush();
      }

      numDomains = nbDomains;
   
      countI = 0;
      curCount = 0;
      maxCount = nbDomains;
    }
  
    virtual void beginDomain(const string & name,
			     int idDomain,
			     int nbValue)
    {
      domainSize[countI] = nbValue;
      domains[countI] = new int[nbValue];
      countJ = 0;
    }

    void addDomainValue(int v)
    {
      domains[countI][countJ++] = v;
    }

    virtual void addDomainValue(int first,int last)
    {
      //if(last-first+1 != domainSize[countI])
      for(int k=first; k<=last; ++k)
	domains[countI][countJ++] = k;
      //else	
    }

    virtual void endDomain()
    {
      domainMax[countI] = -1*NOVAL;
      domainMin[countI] =    NOVAL;
      int k=domainSize[countI];
      while( k-- ) {
	if( domains[countI][k] > domainMax[countI] )
	  domainMax[countI] = domains[countI][k];
	if( domains[countI][k] < domainMin[countI] )
	  domainMin[countI] = domains[countI][k];
      }

      ++countI;

      while(curCount < ((int)(10 * countI / maxCount))) {
	++curCount;
	if( verbose ) {
	  cout << ".";
	  cout.flush();
	}	
      }
    }

    /*!
     * end the definition of all domains
     */
    virtual void endDomainsSection()
    {
      assert( countI == numDomains );

      if( verbose ) {
	time_now = getRunTime();
	cout << setw(6) << setprecision(5)
	     << (time_now - time_last) << "\t(" << numDomains 
	     << " domains)" << endl;
	if( verbose > 2 )
	  for(int i=0; i<numDomains; ++i)
	    {
	      cout << "D" << i << ":" ;
	      for(int j=0; j<domainSize[i]; ++j)
		cout << " " << domains[i][j];
	      cout << endl;
	    }
	time_last = time_now;
      }
    }


    virtual void beginVariablesSection(int nbVariables)
    {
      if( verbose ) {
	//time_now = getRunTime();
	cout << "c" << setw(10) << " " << "variables..." ;
	cout.flush();
      }

      numVariables = nbVariables;
      X.resize( numVariables );
      //solution = new int[numVariables];
      //params = new int[numVariables+1];
      D = new int[numVariables];

      countI = 0;
      curCount = 0;
      maxCount = nbVariables;
    }
  
    virtual void addVariable(const string & name, int idVar,
			     const string & domain, int idDomain)
    {

      ++countI;
      D[idVar] = idDomain;
      //solution[idVar] = domainMin[idDomain];

      while(curCount < ((int)(10 * countI / maxCount))) {
	++curCount;
	if( verbose ) {
	  cout << ".";
	  cout.flush();
	}
      }
    }
      

    virtual void endVariablesSection()
    {
      assert( countI == numVariables );

      model.add( X );

      if( verbose ) {
	time_now = getRunTime();
	cout << setw(6) << setprecision(5)
	     << (time_now - time_last) << "\t(" << numVariables 
	     << " variables)" << endl;
	time_last = time_now;
      }
    }


    virtual void beginRelationsSection(int nbRelations)
    {
      if( verbose ) {
	cout << "c" << setw(10) << " " << "relations..." ;
	cout.flush();
      }

      numRelations = nbRelations;
      relationsIndex = new int[numRelations];
      relationSpin = new int[numRelations];

      countI = 0;
      curCount = 0;
      maxCount = nbRelations;
    }
      
  
    virtual void beginRelation(const string & name, int idRel,
			       int arity, int nbTuples, RelType relType) 
    {
      //relationsIndex[countI] = CSP::addTable( arity, nbTuples );
      //relationSpin[countI] = (relType == REL_SUPPORT);
      countJ=0;
    }
    
    virtual void addRelationTuple(int arity, int tuple[]) 
    {
      //CSP::addTuple( relationsIndex[countI], tuple );
      ++countJ;
    }

    virtual void addRelationTuple(int arity, int tuple[], int cost) 
    {      
    }

    virtual void endRelation()
    {
      ++countI;

      while(curCount < ((int)(10 * countI / maxCount))) {
	++curCount;
	if( verbose ) {
	  cout << ".";
	  cout.flush();
	}
      }
    }

    virtual void endRelationsSection()
    {
      assert( countI == numRelations );
      
      if( verbose ) {
	time_now = getRunTime();
	cout << setw(6) << setprecision(5)
	     << (time_now - time_last) << "\t(" << numRelations 
	     << " relations)" << endl;
	time_last = time_now;
      }
    }

    virtual void beginPredicatesSection(int nbPredicates)
    {
      if( verbose ) {
	cout << "c" << setw(10) << " " << "predicates.." ;
	cout.flush();
      }
      
      numPredicates = nbPredicates;
      predicates = new AST*[numPredicates];
      countI = 0;
      curCount = 0;
      maxCount = nbPredicates;
    }
  
    virtual void beginPredicate(const string & name, int idPred)
    {
      //cout << name << " " << idPred << endl;
    }

    virtual void addFormalParameter(int pos, const string & name,
				    const string & type)
    {
    }

    virtual void predicateExpression(AST *tree)
    {
      predicates[countI] = tree;
    }

    virtual void predicateExpression(const string &expr)
    {
      cerr << "cannot handle expressions in this form" << endl;
      exit(0);
    }

    virtual void endPredicate()
    {
      ++countI;

      while(curCount < ((int)(10 * countI / maxCount))) {
	++curCount;
	if( verbose ) {
	  cout << ".";
	  cout.flush();
	}
      }
    }

    virtual void endPredicatesSection()
    {
      assert( countI == numPredicates );

      if( verbose ) {
	time_now = getRunTime();
	cout << setw(6) << setprecision(5)
	     << (time_now - time_last) << "\t(" << numPredicates 
	     << " predicates)" << endl;
	time_last = time_now;
      }
    }

    virtual void beginConstraintsSection(int nbConstraints)
    {
      if( verbose ) {
	cout << "c" << setw(10) << " " << "constraints." ;
	cout.flush();
      }

      numConstraints = nbConstraints;
      countI = 0;
      curCount = 0;
      maxCount = nbConstraints;
    }
  
    virtual void beginConstraint(const string & name, int idConstr,
				 int arity, 
				 const string & reference, 
				 CSPDefinitionType type, int id,
				 const ASTList &scope)
    {
      if( arity > maxArity ) maxArity = arity;

      idcur = id;
      curtype = type;
      consArity = arity;
      constraintScope.clear();
      predicateScope.clear();
      // for(int i=0; i<arity; ++i) 
      // 	constraintScope.add( X[scope[i].getVarId()] );
      constraintReference=reference;

    }

    virtual void constraintParameters(const ASTList &args) 
    {
      if (constraintReference=="global:cumulative")
	{
	}
      else if (constraintReference=="global:element")
	{
	}
      else if (constraintReference=="global:weightedsum")
	{
	}
      else if (constraintReference=="global:global_cardinality")
	{
	}
      else 
	{
	}
    }


    virtual void endConstraint()
    {
      
      if( curtype == RelationType ) {
	++numEXTCons;
	if( consArity == 2 )
	  ++numBinExt;
	else if( consArity < 5 )
	  ++numNaryExt;
	else
	  ++numLargeExt;
	// Table con( constraintScope, relationsIndex[idcur], relationSpin[idcur] ;
	// model.add( con );  
      } else if( curtype == PredicateType ) { 


      } else if( curtype == GlobalConstraintType ) {
	++numGlobal;
	if (constraintReference=="global:alldifferent") {
	  ++numAllDiff;
	  //model.add( AllDifferent(constraintScope) ); 
	} else if (constraintReference=="global:element") {
	  ++numElement;
	  //model.add( Element(predicateScope) );
	} else if (constraintReference=="global:weightedsum") {
	  ++numWeightedSum;
	} else if (constraintReference=="global:cumulative" ) {
	  ++numCumulative;
	} else if (constraintReference=="global:global_cardinality" ) {
	  ++numGlobalCardinality;
	} else {
	  cout << endl << "s NOT SUPPORTED" << endl;
	  exit(0);
	}
      }

      ++countI;
      
      while(curCount < ((int)(10 * countI / maxCount))) {
	++curCount;
	if( verbose ) {
	  cout << ".";
	  cout.flush();
	}
      }
    }

    /**
     * end the definition of all constraints
     */
    virtual void endConstraintsSection()
    {
      // if( numRelations ) {
      // 	delete [] relationSpin;
      // 	delete [] relationsIndex;
      // }

      for(int k=0; k<numDomains; ++k)
	delete [] domains[k];
      delete [] domains;
      // if( numPredicates ) {
      // 	delete [] predicateCount;
      // 	delete [] predicateScore;
      // }
      if( verbose ) {
	time_now = getRunTime();
	cout << setw(6) << setprecision(5)
	     << (time_now - time_last) << "\t(" << numConstraints 
	     << " constraints)" << endl;
	time_last = time_now;
      }
    }

    /********************************************************************/


    /*!
     * signal the end of parsing
     */
    virtual void endInstance()
    {
      if( verbose > 1 ) {
	cout << "c\n"
	     << "c" << setw(10) << numEXTCons << " extensional constraints" << endl
	     << "c" << setw(10) << numPred << " predicates " << endl
      }
      if( verbose ) {
	time_last = getRunTime();
	time_now = (time_last - time_start);
	cout << "c Parsing time: " << setw(6) 
	     << setprecision(5) << time_now 
	     << "\nc\nc Building model" << endl;
      }
    }

    int solve() {
    }


    void print_outcome(int result) {
    }

    void cleanup() {
      if( numPredicates ) {
	for(int i=0; i<numPredicates; ++i)
	  delete predicates[i];
	delete [] predicates;
      }
      // delete [] solution;
      // delete [] params;
      delete [] D;
      delete [] domainSize;
      delete [] domainMax;
      delete [] domainMin;
      // delete [] features_vec;
      // int i=trash.size;
      // while( i-- )
      // 	delete trash[i];
      // delete cp_solver;
      // delete sat_solver;
    }


  };

}; // namespace

#endif

